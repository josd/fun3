1/ include _nested_ vars in fn params
problem with ungrcoll's; their vars become available (as regular vars) for rest of rule
so pass them like regular vars

2/ mappings: previously, for spo: we already know mapping (s<>s, p<>p, o<>o)
now, we need to first establish mapping, and then unify accordingly

map_collections
    recursive match between match_r, clause_r
    return map: atomic terms / vars match_r with atomic terms / vars clause_r

for match rule:
    given match_r from rule:
        map_collections (clause_r, match_r)
        apply unify on mapped terms

for data find: 
    given match_r from result:
        map_collections (clause_r, match_r)
        apply unify on mapped terms (all in match_r will be concrete)

3/ dealing with var - ungrcoll maps (both directions)
(note that these cases can also occur in a nested collection, not only at top level)

clause (ungrcoll) - match (var) (this will always be case for data.find)
    we don't know yet what match (var) will yield (still-unknown); will only know at runtime
    more fine-grained map: from_match, runtime, nested_clause_term, match_var[nested pos x, y]
        (why term; ungrcoll can have both cnsts & vars; all need to be matched with still-unknown coll from var)
    to_match, direct, ungrcoll (try grounding), match_var

clause (var) - match (ungrcoll)
    more fine-grained map: to_match, runtime, clause_var[pos x, y], nested_clause_term
        each time, also check if clause_var has_runtime_value 
        (we always know that match has_runtime_value, so not needed above)
    from_match, direct, ungrcoll, clause_var (use at our own peril)

x/ simply...
basic unification approach -
if clause term is a var: it is possible that it was given as a function parameter (c.1), and we need a value for it here (c.2)
    = provide input (c.1), accept output (c.2)
if match term is a var: we need to pass a value for it (m.1), and the matching function will pass a value back for it (m.2).
    = accept input (m.1), provide output (m.2)

complication here:
ungrcoll may contain vars as well, to which the above also applies

ungrcoll in match, so nested vars:
(m.1): deconstruct the clause ungrcoll, if it was given (c.1)
    also check if static structure is same
(c.2): return & ground clause ungrcoll (m.2)

ungrcoll in clause, so nested vars:
(m.1): pass & ground ungrcoll (c.1)
(c.2): deconstruct the match ungrcoll (m.2)
    also check if static structure is same

so,
if clause is var, match is ungrcoll:
    call: deconstruct clause var to match ungrcoll
    result: pass match ungrcoll (try grounding) to clause var

if clause is ungrcoll, match is var:
    call: pass clause ungrcoll (try grounding) to match var
    result: deconstruct match var to clause's ungrcoll