1/ include _nested_ vars in fn params
problem with ungrcoll's; their vars become available (as regular vars) for rest of rule
so pass them like regular vars

2/ unification
basic unification approach -
if clause term is a var: it is possible that it was given as a function parameter (c.1), and we need a value for it here (c.2)
    = provide input (c.1), accept output (c.2)
if match term is a var: we need to pass a value for it (m.1), and the matching function will pass a value back for it (m.2).
    = accept input (m.1), provide output (m.2)

complication here:
ungrcoll may contain vars as well, to which the above also applies

ungrcoll in match, so nested vars:
(m.1): deconstruct the clause ungrcoll, if it was given (c.1)
    also check if static structure is same
(c.2): return & ground clause ungrcoll (m.2)

ungrcoll in clause, so nested vars:
(m.1): pass & ground ungrcoll (c.1)
(c.2): deconstruct the match ungrcoll (m.2)
    also check if static structure is same

so,
if clause is var, match is ungrcoll:
    call: deconstruct clause var to match ungrcoll
    result: pass match ungrcoll (try grounding) to clause var

if clause is ungrcoll, match is var:
    call: pass clause ungrcoll (try grounding) to match var
    result: deconstruct match var to clause's ungrcoll